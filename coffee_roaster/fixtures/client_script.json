[
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Sales Invoice",
  "enabled": 0,
  "modified": "2025-07-13 17:02:12.635710",
  "module": null,
  "name": "Sales Invoice script",
  "script": "frappe.ui.form.on('Sales Invoice', {\n    validate(frm) {\n        // run only if flagged as VAT invoice\n        if (frm.doc.is_vat_invoice) {\n            // pick rate (allow per-invoice override)\n            let rate = flt(frm.doc.vat_rate || 0);\n            // net total BEFORE existing taxes\n            let base = flt(frm.doc.net_total || 0);\n\n            frm.doc.net_total_excl_vat = base;\n            frm.doc.vat_amount = (rate / 100) * base;\n\n            // ensure a VAT row exists in taxes table\n            let vat_row = (frm.doc.taxes || []).find(\n                r => r.account_head && r.account_head.includes(\"VAT Liability\")\n            );\n            if (!vat_row) {\n                vat_row = frm.add_child(\"taxes\", {\n                    charge_type: \"On Net Total\",\n                    account_head: \"VAT Liability\",\n                    rate: rate\n                });\n            } else {\n                vat_row.rate = rate;\n            }\n        } else {\n            frm.doc.vat_amount = 0;\n            frm.doc.net_total_excl_vat = frm.doc.net_total;\n            // optionally remove VAT row if box unticked\n            frm.doc.taxes = (frm.doc.taxes || [])\n                .filter(r => !(r.account_head && r.account_head.includes(\"VAT Liability\")));\n        }\n    }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Green Bean Assessment",
  "enabled": 1,
  "modified": "2025-06-22 09:59:46.519872",
  "module": null,
  "name": "Sample ID script",
  "script": "frappe.ui.form.on('Green Bean Assessment', {\n    validate: function(frm) {\n        if (!frm.doc.sample_id) {\n            const now = frappe.datetime.now_date();  // YYYY-MM-DD\n            const mm = now.split(\"-\")[1];\n            const yy = now.split(\"-\")[0].slice(-2);\n            const prefix = mm + yy;\n\n            frappe.call({\n                method: \"frappe.client.get_list\",\n                args: {\n                    doctype: \"Green Bean Assessment\",\n                    filters: [[\"sample_id\", \"like\", prefix + \"%\"]],\n                    fields: [\"name\", \"sample_id\"],\n                    limit: 1000\n                },\n                async: false, // this forces sync (important!)\n                callback: function(r) {\n                    let max = 0;\n                    (r.message || []).forEach(doc => {\n                        const num = parseInt(doc.sample_id?.slice(4)) || 0;\n                        if (num > max) max = num;\n                    });\n                    const next = (max + 1).toString().padStart(5, \"0\");\n                    frm.set_value(\"sample_id\", prefix + next);\n                }\n            });\n        }\n    }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Green Bean Assessment",
  "enabled": 0,
  "modified": "2025-07-11 04:16:34.947293",
  "module": null,
  "name": "Green Bean Assessment",
  "script": "function calculate_all_totals(frm) {\n    let total1 = 0;\n    if (frm.doc.cat1_defects) {\n        frm.doc.cat1_defects.forEach(d => {\n            total1 += d.defect_count || 0;\n        });\n    }\n    frm.set_value(\"total_cat1_defects\", total1);\n\n    let total2 = 0;\n    if (frm.doc.cat2_defects) {\n        frm.doc.cat2_defects.forEach(d => {\n            total2 += d.defect_count || 0;\n        });\n    }\n    frm.set_value(\"total_cat2_defects\", total2);\n\n    frm.set_value(\"total_defects\", total1 + total2);\n}\n\nfrappe.ui.form.on(\"Green Bean Assessment\", {\n    refresh(frm) {\n        calculate_all_totals(frm);\n    },\n    cat1_defects_add(frm) {\n        calculate_all_totals(frm);\n    },\n    cat1_defects_remove(frm) {\n        calculate_all_totals(frm);\n    },\n    cat2_defects_add(frm) {\n        calculate_all_totals(frm);\n    },\n    cat2_defects_remove(frm) {\n        calculate_all_totals(frm);\n    }\n});\n\nfrappe.ui.form.on(\"Category 1 Defect Entry\", {\n    defect_count(frm) {\n        calculate_all_totals(frm);\n    }\n});\n\nfrappe.ui.form.on(\"Category 2 Defect Entry\", {\n    defect_count(frm) {\n        calculate_all_totals(frm);\n    }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Affective Cupping",
  "enabled": 1,
  "modified": "2025-06-24 12:01:48.290994",
  "module": null,
  "name": "ffective Cupping",
  "script": "frappe.ui.form.on('Affective Cupping', {\n  cup_scores_add: function(frm) {\n    calculate_final_score(frm);\n  },\n  cup_scores_remove: function(frm) {\n    calculate_final_score(frm);\n  },\n  // This triggers when the 'score' field of a row changes:\n  cup_scores_score: function(frm, cdt, cdn) {\n    calculate_final_score(frm);\n  }\n});\n\nfunction calculate_final_score(frm) {\n  let total = 0;\n  let count = 0;\n\n  (frm.doc.cup_scores || []).forEach(row => {\n    if (row.score !== undefined && row.score !== null) {\n      total += row.score;\n      count += 1;\n    }\n  });\n\n  let avg = count > 0 ? (total / count) : 0;\n\n  frm.set_value('final_score', avg);\n  frm.refresh_field('final_score');\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Physical Assessment",
  "enabled": 1,
  "modified": "2025-07-12 23:07:31.669636",
  "module": null,
  "name": "Physical Assessment script",
  "script": "frappe.ui.form.on('Physical Assessment', {\n  // Recalculate anytime the form is loaded or any count field changes\n  refresh(frm) {\n    calculate(frm);\n  },\n  // You could also hook into each count field individually, but this blanket\n  // listener is simpler and still performant on ~30 fields.\n  validate(frm) {\n    calculate(frm);\n  }\n});\n\nfunction calculate(frm) {\n  let total = 0.0;\n\n  // Helper to parse ratio like \"5 : 1\" ‚Üí 5\n  const parseRatio = (s) => {\n    let parts = s.split(':');\n    return parseFloat(parts[0]) || 1;\n  };\n\n  // List all count/defect pairs defined in your DocType JSON\n  const pairs = [\n    ['full_black_count','full_black_defects',          '1 : 1'],\n    ['full_sour_count','full_sour_defects',            '1 : 1'],\n    ['dried_cherry_count','dried_cherry_defects',      '1 : 1'],\n    ['fungus_damage_count','fungus_damage_defects',    '1 : 1'],\n    ['foreign_matter_count','foreign_matter_defects',  '1 : 1'],\n    ['severe_insect_damage_count','severe_insect_damage_defects', '5 : 1'],\n\n    ['partial_black_count','partial_black_defects',    '3 : 1'],\n    ['partial_sour_count','partial_sour_defects',      '3 : 1'],\n    ['parchment_count','parchment_defects',            '5 : 1'],\n    ['floater_count','floater_defects',                '5 : 1'],\n    ['immature_count','immature_defects',              '5 : 1'],\n    ['withered_count','withered_defects',              '5 : 1'],\n    ['shell_count','shell_defects',                    '5 : 1'],\n    ['broken_chipped_count','broken_chipped_defects',  '5 : 1'],\n    ['hull_husk_count','hull_husk_defects',            '5 : 1'],\n    ['slight_insect_damage_count','slight_insect_damage_defects','10 : 1']\n  ];\n\n  // Compute per‚Äêpair and accumulate\n  pairs.forEach(([cnt, fld, ratio]) => {\n    let count = cint(frm.doc[cnt] || 0);\n    let r = parseRatio(ratio);\n    let full = (count / r) || 0;\n    full = Math.round(full * 100) / 100;          // two decimals\n    frm.set_value(fld, full);\n    total += full;\n  });\n\n  // Set total\n  frm.set_value('total_full_defects', total);\n\n // Determine grade\n  let grade;\n  if (total <= 3)        grade = '1';\n else if (total <= 12)  grade = '2';\nelse if (total <= 25)  grade = '3';\nelse if (total <= 45)  grade = '4';\n else if (total <= 100) grade = '5';\n else                   grade = '6-9';\n\n frm.set_value('grade', grade);\n}\nfrappe.ui.form.on('Physical Assessment', {\n    // this runs on both a brand-new form and after every save\n    refresh(frm) {\n        const show = true;   // always visible\n\n        // call once per field you want to show / hide\n        frm.toggle_display('sec_break_summary', show);   // the section label\n        frm.toggle_display('max_screen_size',   show);   // the field inside\n        // add more lines if you need other fields\n    }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Physical Assessment",
  "enabled": 1,
  "modified": "2025-07-12 20:50:25.993979",
  "module": null,
  "name": "Physical Assessment bean size",
  "script": "/**  Physical Assessment ‚Äì screen-size metrics\n *   ‚Ä¢ % = bean_count / 300 * 100   (fixed denominator)\n *   ‚Ä¢ max_screen_size = screen # with the largest count\n *   Works with individual fields: screen10_count ‚Ä¶ screen23_count\n */\n\nfrappe.ui.form.on('Physical Assessment', (() => {\n    // ------------------------------------------------------------------\n    // config\n    // ------------------------------------------------------------------\n    const SAMPLE_SIZE = 300;               // fixed denominator\n    const SCREENS     = Array.from({length: 14}, (_, i) => 10 + i);  // 10 ‚Ä¶ 23\n\n    // ------------------------------------------------------------------\n    // helper ‚Äì recalc everything\n    // ------------------------------------------------------------------\n    function update_screen_metrics(frm) {\n        let maxCount = 0;\n        let maxSize  = 0;\n\n        SCREENS.forEach(size => {\n            // read the *_count field (defaults to 0)\n            const count  = cint(frm.doc[`screen${size}_count`]) || 0;\n            // ------------------------------------------------------------------\n// summary line: ‚Äú90 beans ‚Ä¢ 30.0 % ‚Ä¢ #17‚Äù (or ‚Äú‚Äì‚Äù if nothing entered)\nconst summaryPct   = (maxCount * 100) / SAMPLE_SIZE;\nconst summaryText  = maxCount\n        ? `${maxCount} beans ‚Ä¢ ${flt(summaryPct, 1)} % ‚Ä¢ #${maxSize}`\n        : '‚Äì';\n\n\n// ------------------------------------------------------------------\n\n\n            // set its % field\n            const pct    = (count * 100) / SAMPLE_SIZE;\n            frm.set_value(`screen${size}_percent`, flt(pct, 2));\n\n            // track max\n            if (count > maxCount) {\n                maxCount = count;\n                maxSize  = size;\n            }\n        });\n\n        frm.set_value('max_screen_size', maxSize || null);\n    }\n\n    // ------------------------------------------------------------------\n    // event map\n    // ------------------------------------------------------------------\n    const events = {\n         onload:  frm => {\n            frm.set_df_property('sec_break_summary', 'hidden', 0);  // üëà new\n            update_screen_metrics(frm);\n        },\n        refresh: update_screen_metrics,\n        validate: update_screen_metrics\n    };\n    // attach a change handler for every *_count field\n    SCREENS.forEach(size => {\n        events[`screen${size}_count`] = update_screen_metrics;\n    });\n\n    return events;\n})());\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Affective Assessment",
  "enabled": 1,
  "modified": "2025-07-03 03:28:16.832403",
  "module": null,
  "name": "Affective Assessment",
  "script": "frappe.ui.form.on('Affective Assessment', {\n  // any time one of these rating fields changes‚Ä¶\n  fragrance_rating: compute_total,\n  aroma_rating:      compute_total,\n  flavor_rating:     compute_total,\n  aftertaste_rating: compute_total,\n  acidity_rating:    compute_total,\n  sweetness_rating:  compute_total,\n  mouthfeel_rating:  compute_total,\n  overall_rating:    compute_total,\n});\n\nfunction compute_total(frm) {\n  // list your rating fields\n  const fields = [\n    'fragrance_rating',\n    'aroma_rating',\n    'flavor_rating',\n    'aftertaste_rating',\n    'acidity_rating',\n    'sweetness_rating',\n    'mouthfeel_rating',\n    'overall_rating'\n  ];\n\n  // sum up the integer values\n  let sum = fields.reduce((acc, f) => {\n    return acc + (parseInt(frm.doc[f]) || 0);\n  }, 0);\n\n  // set the total_score field\n  frm.set_value('total_score', sum);\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Roasted Coffee",
  "enabled": 1,
  "modified": "2025-07-10 12:29:42.507899",
  "module": null,
  "name": "script for roasted coffe stock button",
  "script": "frappe.ui.form.on('Roasted Coffee', {\n  refresh: function(frm) {\n    if (!frm.is_new() && !frm.doc.stock_entry) {\n      frm.add_custom_button(__('Create Stock Entry'), function() {\n        frappe.call({\n          method: 'coffee_roaster.api.create_stock_entry_from_roasted',\n          args: { roasted_name: frm.doc.name },\n          callback: function(r) {\n            if (!r.exc) {\n              frm.reload_doc();\n            }\n          }\n        });\n      }, __(\"Actions\"));\n    }\n  }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Affective Assessment",
  "enabled": 1,
  "modified": "2025-07-12 21:15:44.102696",
  "module": null,
  "name": "Affective Assessment script",
  "script": "// ------------------------------------------------------------------\n//  TOTAL SCORE  +  CUP GRADE\n//  --------------------------------------------------------------\n//  ‚Ä¢ Takes the eight *_score hidden Ints (values 1-10)\n//  ‚Ä¢ Calculates cup score on a 0-100 scale (1 decimal place)\n//  ‚Ä¢ Maps to Grade 1-9 using your table\n// ------------------------------------------------------------------\n\nfunction update_total_and_grade(frm) {\n    const ATTR = [\n        'fragrance_score', 'aroma_score',     'flavor_score',  'aftertaste_score',\n        'acidity_score',   'sweetness_score', 'mouthfeel_score','overall_score'\n    ];\n\n    // Sum the eight attributes (0 if still blank)\n    let sum = 0;\n    ATTR.forEach(f => { sum += parseInt(frm.doc[f] || 0, 10); });\n\n    const avg10 = sum / ATTR.length;                   // 0-10 scale\n    const cup   = Math.round(avg10 * 10 * 10) / 10;    // 0-100, 1 dp\n\n    frm.set_value('total_score', cup);                 // live Total Score\n    frm.refresh_field('total_score');\n\n    // grade lookup\n    let grade;\n    if      (cup >=  85) grade = 1;        // Specialty\n    else if (cup >=  80) grade = 2;\n    else if (cup >=  75) grade = 3;\n    else if (cup >=  70) grade = 4;\n    else if (cup >=  65) grade = 5;\n    else                  grade = 6;       // 6-9 below 65\n\n    frm.set_value('grade', grade);\n    frm.refresh_field('grade');\n}\n\n// ------------------------------------------------------------------\n//  Call the helper whenever a score might change\n// ------------------------------------------------------------------\n\n// 1Ô∏è‚É£  After every box click (add this at the end of your handle_click)\nfunction handle_click(frm, attr, value) {\n    // ... your existing untick + set score code ...\n    update_total_and_grade(frm);   // <= add this line\n}\n\n// 2Ô∏è‚É£  Also on load / refresh so imported data are graded\nfrappe.ui.form.on('Affective Assessment', {\n    onload(frm)  { update_total_and_grade(frm); },\n    refresh(frm) { update_total_and_grade(frm); }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Sales Order",
  "enabled": 0,
  "modified": "2025-07-14 00:50:16.419832",
  "module": "roaster",
  "name": "Auto Price List on Sales Order",
  "script": "frappe.ui.form.on(\"Sales Order\",{\n    onload(frm){set_price_list(frm);},\n    customer(frm){set_price_list(frm);}  \n});\nfunction set_price_list(frm){\n    if(!frm.doc.customer)return;\n    frappe.db.get_value(\"Customer\",frm.doc.customer,\"customer_channel\")\n        .then(r=>{\n            const ch=r.message.customer_channel;\n            const pl=ch===\"Wholesale\"?\"Coffee Wholesale - ETB\":\"Coffee Retail - ETB\";\n            if(frm.doc.selling_price_list!==pl){frm.set_value(\"selling_price_list\",pl);}\n        });\n}",
  "view": null
 }
]